{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b59517cc-b77f-442a-84d5-4a07b94c066e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "============================================================\n",
      "CELL ANALYSIS SCRIPT FOR FORECAST DATA\n",
      "============================================================\n",
      "Category: 1221\n",
      "Service: 630\n",
      "Time Period: February 1, 2025\n",
      "SAS File: Q:\\ForecastOFM\\Production\\NwCycle2524_02\\ForecastPTFmap\\Forecast Process Specific Files\\Cycle 2524\\Version A\\Primary Trend\\modelinput.sas7bdat\n",
      "============================================================\n",
      "About to import SAS data...\n",
      "Importing SAS data from: Q:\\ForecastOFM\\Production\\NwCycle2524_02\\ForecastPTFmap\\Forecast Process Specific Files\\Cycle 2524\\Version A\\Primary Trend\\modelinput.sas7bdat\n",
      "Successfully imported 67760 rows and 9 columns\n",
      "Columns: ['BienniumMonthID', 'category', 'service', 'MOS', 'Total', 'bratio', 'Fratio', 'Eligibles', 'perCap']\n",
      "Cleaning data columns...\n",
      "Cleaned 'category' column\n",
      "Cleaned 'service' column\n",
      "Removing rows with missing Eligibles data...\n",
      "Removed 6969 rows with missing Eligibles data\n",
      "Data reduced from 67760 to 60791 rows\n",
      "SAS data imported successfully, proceeding to display info...\n",
      "\n",
      "Data shape: (60791, 9)\n",
      "Data types:\n",
      "BienniumMonthID           object\n",
      "category                  object\n",
      "service                   object\n",
      "MOS                datetime64[s]\n",
      "Total                    float64\n",
      "bratio                   float64\n",
      "Fratio                   float64\n",
      "Eligibles                float64\n",
      "perCap                   float64\n",
      "dtype: object\n",
      "\n",
      "First few rows:\n",
      "  BienniumMonthID category service        MOS  Total  bratio  Fratio  \\\n",
      "0         b'2524'     1211     101 2018-07-01    NaN     NaN     NaN   \n",
      "1         b'2524'     1211     101 2018-08-01    NaN     NaN     NaN   \n",
      "2         b'2524'     1211     101 2018-09-01    NaN     NaN     NaN   \n",
      "3         b'2524'     1211     101 2018-10-01    NaN     NaN     NaN   \n",
      "4         b'2524'     1211     101 2018-11-01    NaN     NaN     NaN   \n",
      "\n",
      "   Eligibles  perCap  \n",
      "0   119518.0     NaN  \n",
      "1   118783.0     NaN  \n",
      "2   117909.0     NaN  \n",
      "3   117575.0     NaN  \n",
      "4   117562.0     NaN  \n",
      "\n",
      "Sample category values: ['1211', '1211', '1211', '1211', '1211', '1211', '1211', '1211', '1211', '1211']\n",
      "Sample service values: ['101', '101', '101', '101', '101', '101', '101', '101', '101', '101']\n",
      "\n",
      "Proceeding to filter data...\n",
      "Found 82 records for category=1221, service=630\n",
      "\n",
      "Cell data shape: (82, 9)\n",
      "Cell data columns: ['BienniumMonthID', 'category', 'service', 'MOS', 'Total', 'bratio', 'Fratio', 'Eligibles', 'perCap']\n",
      "\n",
      "Cell data summary:\n",
      "                       MOS         Total  bratio  Fratio      Eligibles  \\\n",
      "count                   82  8.200000e+01    82.0    82.0      82.000000   \n",
      "mean   2021-11-15 12:35:07  2.648568e+08     1.0     1.0  651246.498000   \n",
      "min    2018-07-01 00:00:00  2.022039e+08     1.0     1.0  525195.000000   \n",
      "25%    2020-03-08 18:00:00  2.264712e+08     1.0     1.0  547775.750000   \n",
      "50%    2021-11-16 00:00:00  2.724184e+08     1.0     1.0  630283.345717   \n",
      "75%    2023-07-24 06:00:00  2.902628e+08     1.0     1.0  733661.250000   \n",
      "max    2025-04-01 00:00:00  3.372526e+08     1.0     1.0  830636.000000   \n",
      "std                    NaN  3.845502e+07     0.0     0.0   97059.439330   \n",
      "\n",
      "           perCap  \n",
      "count   82.000000  \n",
      "mean   407.220946  \n",
      "min    378.185861  \n",
      "25%    391.432590  \n",
      "50%    404.461028  \n",
      "75%    411.548880  \n",
      "max    477.125331  \n",
      "std     20.913556  \n",
      "\n",
      "Attempting to create chart...\n",
      "Cell data info:\n",
      "  - Shape: (82, 9)\n",
      "  - Columns: ['BienniumMonthID', 'category', 'service', 'MOS', 'Total', 'bratio', 'Fratio', 'Eligibles', 'perCap']\n",
      "  - Data types: {'BienniumMonthID': dtype('O'), 'category': dtype('O'), 'service': dtype('O'), 'MOS': dtype('<M8[s]'), 'Total': dtype('float64'), 'bratio': dtype('float64'), 'Fratio': dtype('float64'), 'Eligibles': dtype('float64'), 'perCap': dtype('float64')}\n",
      "Creating chart for cell data with 82 records...\n",
      "Available columns: ['BienniumMonthID', 'category', 'service', 'MOS', 'Total', 'bratio', 'Fratio', 'Eligibles', 'perCap']\n",
      "Output directory created/verified: cell_charts\n",
      "Figure and axis created successfully\n",
      "'MOS' column found, sorting data...\n",
      "X-axis data (MOS): [Timestamp('2018-07-01 00:00:00'), Timestamp('2018-08-01 00:00:00'), Timestamp('2018-09-01 00:00:00'), Timestamp('2018-10-01 00:00:00'), Timestamp('2018-11-01 00:00:00'), Timestamp('2018-12-01 00:00:00'), Timestamp('2019-01-01 00:00:00'), Timestamp('2019-02-01 00:00:00'), Timestamp('2019-03-01 00:00:00'), Timestamp('2019-04-01 00:00:00'), Timestamp('2019-05-01 00:00:00'), Timestamp('2019-06-01 00:00:00'), Timestamp('2019-07-01 00:00:00'), Timestamp('2019-08-01 00:00:00'), Timestamp('2019-09-01 00:00:00'), Timestamp('2019-10-01 00:00:00'), Timestamp('2019-11-01 00:00:00'), Timestamp('2019-12-01 00:00:00'), Timestamp('2020-01-01 00:00:00'), Timestamp('2020-02-01 00:00:00'), Timestamp('2020-03-01 00:00:00'), Timestamp('2020-04-01 00:00:00'), Timestamp('2020-05-01 00:00:00'), Timestamp('2020-06-01 00:00:00'), Timestamp('2020-07-01 00:00:00'), Timestamp('2020-08-01 00:00:00'), Timestamp('2020-09-01 00:00:00'), Timestamp('2020-10-01 00:00:00'), Timestamp('2020-11-01 00:00:00'), Timestamp('2020-12-01 00:00:00'), Timestamp('2021-01-01 00:00:00'), Timestamp('2021-02-01 00:00:00'), Timestamp('2021-03-01 00:00:00'), Timestamp('2021-04-01 00:00:00'), Timestamp('2021-05-01 00:00:00'), Timestamp('2021-06-01 00:00:00'), Timestamp('2021-07-01 00:00:00'), Timestamp('2021-08-01 00:00:00'), Timestamp('2021-09-01 00:00:00'), Timestamp('2021-10-01 00:00:00'), Timestamp('2021-11-01 00:00:00'), Timestamp('2021-12-01 00:00:00'), Timestamp('2022-01-01 00:00:00'), Timestamp('2022-02-01 00:00:00'), Timestamp('2022-03-01 00:00:00'), Timestamp('2022-04-01 00:00:00'), Timestamp('2022-05-01 00:00:00'), Timestamp('2022-06-01 00:00:00'), Timestamp('2022-07-01 00:00:00'), Timestamp('2022-08-01 00:00:00'), Timestamp('2022-09-01 00:00:00'), Timestamp('2022-10-01 00:00:00'), Timestamp('2022-11-01 00:00:00'), Timestamp('2022-12-01 00:00:00'), Timestamp('2023-01-01 00:00:00'), Timestamp('2023-02-01 00:00:00'), Timestamp('2023-03-01 00:00:00'), Timestamp('2023-04-01 00:00:00'), Timestamp('2023-05-01 00:00:00'), Timestamp('2023-06-01 00:00:00'), Timestamp('2023-07-01 00:00:00'), Timestamp('2023-08-01 00:00:00'), Timestamp('2023-09-01 00:00:00'), Timestamp('2023-10-01 00:00:00'), Timestamp('2023-11-01 00:00:00'), Timestamp('2023-12-01 00:00:00'), Timestamp('2024-01-01 00:00:00'), Timestamp('2024-02-01 00:00:00'), Timestamp('2024-03-01 00:00:00'), Timestamp('2024-04-01 00:00:00'), Timestamp('2024-05-01 00:00:00'), Timestamp('2024-06-01 00:00:00'), Timestamp('2024-07-01 00:00:00'), Timestamp('2024-08-01 00:00:00'), Timestamp('2024-09-01 00:00:00'), Timestamp('2024-10-01 00:00:00'), Timestamp('2024-11-01 00:00:00'), Timestamp('2024-12-01 00:00:00'), Timestamp('2025-01-01 00:00:00'), Timestamp('2025-02-01 00:00:00'), Timestamp('2025-03-01 00:00:00'), Timestamp('2025-04-01 00:00:00')]\n",
      "Y-axis data (perCap): [387.7879895241341, 390.5941583798831, 383.42853815219223, 398.194630900015, 393.1352970261302, 390.13248570349094, 389.2767374520244, 378.18586124473484, 386.65289738995455, 392.31823666125433, 394.78780380642974, 391.13737482111867, 403.94100812884585, 400.80129179547885, 395.1200573501271, 404.46270911797535, 390.5838959819825, 400.6638324659028, 406.1956023280539, 400.147198215972, 418.46606786677995, 409.3728247279296, 404.07528516739995, 409.8418969983951, 409.6064121222791, 405.7451324479737, 404.9460714483531, 407.102878706329, 400.88959349504233, 404.4593470642136, 408.1658629707191, 408.2300392435822, 409.160736364226, 412.140605882087, 411.730668244804, 409.9528750735157, 394.70812226783147, 395.02863484752004, 395.2055092521921, 399.84340824990545, 400.1767787877552, 400.91332767151016, 384.6314355154286, 383.4911317214595, 383.2243054086352, 383.2466576354422, 383.3754549193341, 383.3862310678833, 387.56734798619567, 387.6271825923313, 387.9135299545351, 388.4033212296504, 388.3471629916966, 388.22934880962487, 404.93645918283767, 403.12306932453544, 407.7851384040582, 404.13065050154347, 405.3837903702713, 406.88698526310424, 404.52384790861186, 408.1643938689343, 407.82980658747795, 412.68692662047056, 411.72190287769394, 411.0298116976817, 426.84593812446104, 425.63588317888247, 427.57038756816075, 429.1073178249222, 429.79453837143234, 429.3219419479219, 438.15398112106345, 436.9064933732997, 436.73846353804345, 438.7175821689131, 437.59594549899214, 439.09441081410307, 477.1253311587671, 467.89398009230723, 467.86784838619474, 468.79191295628317]\n",
      "Line plot created successfully\n",
      "Scatter points added successfully\n",
      "Chart labels and title set successfully\n",
      "Chart layout finalized successfully\n",
      "Generated filename: cell_1221_630_20250820_150325.pdf\n",
      "Chart saved successfully as: cell_charts\\cell_1221_630_20250820_150325.pdf\n",
      "Figure closed, memory freed\n",
      "\n",
      "✅ Analysis completed successfully!\n",
      "📊 Chart saved to: cell_charts\\cell_1221_630_20250820_150325.pdf\n",
      "\n",
      "============================================================\n"
     ]
    }
   ],
   "source": [
    "#!/usr/bin/env python3\n",
    "\"\"\"\n",
    "Cell Analysis Script for Forecast Data\n",
    "Imports SAS data and creates graphs for specific category-service combinations\n",
    "\"\"\"\n",
    "\n",
    "import pandas as pd\n",
    "import matplotlib\n",
    "matplotlib.use('Agg')  # Use non-interactive backend\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.dates as mdates\n",
    "import numpy as np\n",
    "from datetime import datetime\n",
    "import os\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# =============================================================================\n",
    "# CONFIGURABLE PARAMETERS - Users can modify these values\n",
    "# =============================================================================\n",
    "\n",
    "# SAS data file path\n",
    "SAS_FILE_PATH = r\"Q:\\ForecastOFM\\Production\\NwCycle2524_02\\ForecastPTFmap\\Forecast Process Specific Files\\Cycle 2524\\Version A\\Primary Trend\\modelinput.sas7bdat\"\n",
    "\n",
    "# Cell parameters - Users can modify these values\n",
    "CATEGORY = '1221'\n",
    "SERVICE = '630'\n",
    "\n",
    "# Time period for analysis - Users can modify this value\n",
    "TIME_PERIOD = \"February 1, 2025\"\n",
    "\n",
    "# Output directory for generated charts\n",
    "OUTPUT_DIR = \"cell_charts\"\n",
    "\n",
    "# Chart styling parameters\n",
    "CHART_WIDTH = 12\n",
    "CHART_HEIGHT = 8\n",
    "DPI = 300\n",
    "\n",
    "# =============================================================================\n",
    "# MAIN ANALYSIS FUNCTION\n",
    "# =============================================================================\n",
    "\n",
    "def import_sas_data(file_path):\n",
    "    \"\"\"\n",
    "    Import SAS data file using pandas\n",
    "    \n",
    "    Args:\n",
    "        file_path (str): Path to the SAS file\n",
    "        \n",
    "    Returns:\n",
    "        pandas.DataFrame: Imported data\n",
    "    \"\"\"\n",
    "    try:\n",
    "        print(f\"Importing SAS data from: {file_path}\")\n",
    "        # Using pandas to read SAS file\n",
    "        df = pd.read_sas(file_path)\n",
    "        print(f\"Successfully imported {len(df)} rows and {len(df.columns)} columns\")\n",
    "        print(f\"Columns: {list(df.columns)}\")\n",
    "        \n",
    "        # Clean the data by removing 'b' prefix from category and service columns\n",
    "        print(\"Cleaning data columns...\")\n",
    "        if 'category' in df.columns:\n",
    "            df['category'] = df['category'].astype(str).str.replace(\"b'\", \"\").str.replace(\"'\", \"\")\n",
    "            print(\"Cleaned 'category' column\")\n",
    "        if 'service' in df.columns:\n",
    "            df['service'] = df['service'].astype(str).str.replace(\"b'\", \"\").str.replace(\"'\", \"\")\n",
    "            print(\"Cleaned 'service' column\")\n",
    "        \n",
    "        # Remove rows where Eligibles is missing\n",
    "        print(\"Removing rows with missing Eligibles data...\")\n",
    "        initial_count = len(df)\n",
    "        df = df.dropna(subset=['Eligibles'])\n",
    "        final_count = len(df)\n",
    "        removed_count = initial_count - final_count\n",
    "        print(f\"Removed {removed_count} rows with missing Eligibles data\")\n",
    "        print(f\"Data reduced from {initial_count} to {final_count} rows\")\n",
    "            \n",
    "        return df\n",
    "    except Exception as e:\n",
    "        print(f\"Error importing SAS data: {e}\")\n",
    "        return None\n",
    "\n",
    "def filter_cell_data(df, category, service):\n",
    "    \"\"\"\n",
    "    Filter data for specific category and service combination\n",
    "    \n",
    "    Args:\n",
    "        df (pandas.DataFrame): Input data\n",
    "        category (str): Category value to filter\n",
    "        service (str): Service value to filter\n",
    "        \n",
    "    Returns:\n",
    "        pandas.DataFrame: Filtered data for the cell\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Filter for the specific cell\n",
    "        cell_data = df[(df['category'] == category) & (df['service'] == service)].copy()\n",
    "        \n",
    "        if len(cell_data) == 0:\n",
    "            print(f\"No data found for category={category}, service={service}\")\n",
    "            return None\n",
    "            \n",
    "        print(f\"Found {len(cell_data)} records for category={category}, service={service}\")\n",
    "        return cell_data\n",
    "        \n",
    "    except KeyError as e:\n",
    "        print(f\"Column not found in data: {e}\")\n",
    "        print(f\"Available columns: {list(df.columns)}\")\n",
    "        return None\n",
    "    except Exception as e:\n",
    "        print(f\"Error filtering data: {e}\")\n",
    "        return None\n",
    "\n",
    "def create_cell_chart(cell_data, category, service, time_period):\n",
    "    \"\"\"\n",
    "    Create a chart for the specified cell\n",
    "    \n",
    "    Args:\n",
    "        cell_data (pandas.DataFrame): Filtered data for the cell\n",
    "        category (str): Category value\n",
    "        service (str): Service value\n",
    "        time_period (str): Time period for analysis\n",
    "    \"\"\"\n",
    "    try:\n",
    "        print(f\"Creating chart for cell data with {len(cell_data)} records...\")\n",
    "        print(f\"Available columns: {list(cell_data.columns)}\")\n",
    "        \n",
    "        # Create output directory if it doesn't exist\n",
    "        os.makedirs(OUTPUT_DIR, exist_ok=True)\n",
    "        print(f\"Output directory created/verified: {OUTPUT_DIR}\")\n",
    "        \n",
    "        # Create figure and axis\n",
    "        fig, ax = plt.subplots(figsize=(CHART_WIDTH, CHART_HEIGHT))\n",
    "        print(\"Figure and axis created successfully\")\n",
    "        \n",
    "        # Sort data by MOS if it exists (note: actual column name is 'MOS')\n",
    "        if 'MOS' in cell_data.columns:\n",
    "            print(\"'MOS' column found, sorting data...\")\n",
    "            cell_data = cell_data.sort_values('MOS')\n",
    "            x_data = cell_data['MOS']\n",
    "            y_data = cell_data['perCap']  # Note: actual column name is 'perCap'\n",
    "            print(f\"X-axis data (MOS): {x_data.tolist()}\")\n",
    "            print(f\"Y-axis data (perCap): {y_data.tolist()}\")\n",
    "        else:\n",
    "            # If MOS column doesn't exist, use index\n",
    "            print(\"Warning: 'MOS' column not found, using index for x-axis\")\n",
    "            x_data = range(len(cell_data))\n",
    "            y_data = cell_data['perCap']  # Note: actual column name is 'perCap'\n",
    "            print(f\"X-axis data (index): {list(x_data)}\")\n",
    "            print(f\"Y-axis data (perCap): {y_data.tolist()}\")\n",
    "        \n",
    "        # Check for NaN or invalid values\n",
    "        if y_data.isna().any():\n",
    "            print(\"Warning: NaN values found in PerCap data\")\n",
    "            y_data = y_data.fillna(0)  # Replace NaN with 0\n",
    "        \n",
    "        # Check if we have valid data to plot\n",
    "        if len(y_data) == 0:\n",
    "            print(\"Error: No valid data to plot\")\n",
    "            return None\n",
    "        \n",
    "        # Ensure y_data is numeric\n",
    "        try:\n",
    "            y_data = pd.to_numeric(y_data, errors='coerce')\n",
    "            if y_data.isna().all():\n",
    "                print(\"Error: All PerCap values are NaN after conversion\")\n",
    "                return None\n",
    "        except Exception as e:\n",
    "            print(f\"Error converting PerCap to numeric: {e}\")\n",
    "            return None\n",
    "        \n",
    "        # Create the line plot\n",
    "        ax.plot(x_data, y_data, marker='o', linewidth=2, markersize=6, \n",
    "                color='#2E86AB', alpha=0.8)\n",
    "        print(\"Line plot created successfully\")\n",
    "        \n",
    "        # Add scatter points\n",
    "        ax.scatter(x_data, y_data, color='#A23B72', s=50, alpha=0.7, zorder=5)\n",
    "        print(\"Scatter points added successfully\")\n",
    "        \n",
    "        # Customize the chart\n",
    "        ax.set_title(f'perCap Trend for Cell (Category: {category}, Service: {service})\\n'\n",
    "                    f'Time Period: {time_period}', \n",
    "                    fontsize=16, fontweight='bold', pad=20)\n",
    "        ax.set_xlabel('Month of Service (MOS)', fontsize=12, fontweight='bold')\n",
    "        ax.set_ylabel('perCap', fontsize=12, fontweight='bold')\n",
    "        print(\"Chart labels and title set successfully\")\n",
    "        \n",
    "        # Add grid\n",
    "        ax.grid(True, alpha=0.3, linestyle='--')\n",
    "        \n",
    "        # Format x-axis for dates\n",
    "        if 'MOS' in cell_data.columns:\n",
    "            # Format dates as yyyy-mm-01\n",
    "            ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-01'))\n",
    "            ax.xaxis.set_major_locator(mdates.MonthLocator(interval=6))  # Show every 6 months\n",
    "            plt.xticks(rotation=45, ha='right')\n",
    "        else:\n",
    "            # Rotate x-axis labels if they're long (for non-date data)\n",
    "            if len(str(x_data.iloc[0])) > 10:\n",
    "                plt.xticks(rotation=45, ha='right')\n",
    "        \n",
    "        # Add value labels on points\n",
    "        # for i, (x, y) in enumerate(zip(x_data, y_data)):\n",
    "        #     ax.annotate(f'{y:.2f}', (x, y), textcoords=\"offset points\", \n",
    "        #                xytext=(0,10), ha='center', fontsize=8, alpha=0.7)\n",
    "        \n",
    "        # Tight layout to prevent label cutoff\n",
    "        plt.tight_layout()\n",
    "        print(\"Chart layout finalized successfully\")\n",
    "        \n",
    "        # Generate timestamped filename\n",
    "        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n",
    "        filename = f\"cell_{category}_{service}_{timestamp}.pdf\"\n",
    "        filepath = os.path.join(OUTPUT_DIR, filename)\n",
    "        print(f\"Generated filename: {filename}\")\n",
    "        \n",
    "        # Save the chart\n",
    "        plt.savefig(filepath, dpi=DPI, bbox_inches='tight', format='pdf')\n",
    "        print(f\"Chart saved successfully as: {filepath}\")\n",
    "        \n",
    "        # Close the figure to free memory\n",
    "        plt.close(fig)\n",
    "        print(\"Figure closed, memory freed\")\n",
    "        \n",
    "        return filepath\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"Error creating chart: {e}\")\n",
    "        import traceback\n",
    "        traceback.print_exc()\n",
    "        return None\n",
    "\n",
    "def main():\n",
    "    \"\"\"\n",
    "    Main function to execute the cell analysis\n",
    "    \"\"\"\n",
    "    print(\"=\" * 60)\n",
    "    print(\"CELL ANALYSIS SCRIPT FOR FORECAST DATA\")\n",
    "    print(\"=\" * 60)\n",
    "    print(f\"Category: {CATEGORY}\")\n",
    "    print(f\"Service: {SERVICE}\")\n",
    "    print(f\"Time Period: {TIME_PERIOD}\")\n",
    "    print(f\"SAS File: {SAS_FILE_PATH}\")\n",
    "    print(\"=\" * 60)\n",
    "    \n",
    "    # Import SAS data\n",
    "    print(\"About to import SAS data...\")\n",
    "    df = import_sas_data(SAS_FILE_PATH)\n",
    "    if df is None:\n",
    "        print(\"Failed to import data. Exiting.\")\n",
    "        return\n",
    "    print(\"SAS data imported successfully, proceeding to display info...\")\n",
    "    \n",
    "    # Display basic data info\n",
    "    try:\n",
    "        print(f\"\\nData shape: {df.shape}\")\n",
    "        print(f\"Data types:\\n{df.dtypes}\")\n",
    "        print(f\"\\nFirst few rows:\")\n",
    "        print(df.head())\n",
    "        \n",
    "        # Show sample values from category and service columns for debugging\n",
    "        if 'category' in df.columns:\n",
    "            print(f\"\\nSample category values: {df['category'].head(10).tolist()}\")\n",
    "        if 'service' in df.columns:\n",
    "            print(f\"Sample service values: {df['service'].head(10).tolist()}\")\n",
    "        \n",
    "        print(\"\\nProceeding to filter data...\")\n",
    "    except Exception as e:\n",
    "        print(f\"Error displaying data info: {e}\")\n",
    "        import traceback\n",
    "        traceback.print_exc()\n",
    "    \n",
    "    # Filter data for the specified cell\n",
    "    cell_data = filter_cell_data(df, CATEGORY, SERVICE)\n",
    "    if cell_data is None:\n",
    "        print(\"Failed to filter data. Exiting.\")\n",
    "        return\n",
    "    \n",
    "    # Display cell data info\n",
    "    print(f\"\\nCell data shape: {cell_data.shape}\")\n",
    "    print(f\"Cell data columns: {list(cell_data.columns)}\")\n",
    "    print(f\"\\nCell data summary:\")\n",
    "    print(cell_data.describe())\n",
    "    \n",
    "    # Check required columns before creating chart\n",
    "    required_columns = ['perCap']  # Note: actual column name is 'perCap'\n",
    "    missing_columns = [col for col in required_columns if col not in cell_data.columns]\n",
    "    \n",
    "    if missing_columns:\n",
    "        print(f\"❌ Missing required columns: {missing_columns}\")\n",
    "        print(f\"Available columns: {list(cell_data.columns)}\")\n",
    "        return\n",
    "    \n",
    "    # Create and save the chart\n",
    "    print(f\"\\nAttempting to create chart...\")\n",
    "    print(f\"Cell data info:\")\n",
    "    print(f\"  - Shape: {cell_data.shape}\")\n",
    "    print(f\"  - Columns: {list(cell_data.columns)}\")\n",
    "    print(f\"  - Data types: {cell_data.dtypes.to_dict()}\")\n",
    "    \n",
    "    chart_file = create_cell_chart(cell_data, CATEGORY, SERVICE, TIME_PERIOD)\n",
    "    if chart_file:\n",
    "        print(f\"\\n✅ Analysis completed successfully!\")\n",
    "        print(f\"📊 Chart saved to: {chart_file}\")\n",
    "    else:\n",
    "        print(f\"\\n❌ Failed to create chart\")\n",
    "    \n",
    "    print(\"\\n\" + \"=\" * 60)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
